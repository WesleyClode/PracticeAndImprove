{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./source/vue/observe/array.js","webpack:///./source/vue/observe/observer.js","webpack:///./source/vue/observe/index.js","webpack:///./source/vue/observe/watcher.js","webpack:///./source/vue/util.js","webpack:///./source/vue/index.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","oldArrayProtoMethods","Array","arrayMethods","observerArray","inserted","length","defineReactive","data","console","log","newValue","forEach","method","args","res","apply","this","slice","isArray","__proto__","walk","keys","initState","vm","opts","$options","_data","proxy","initData","computed","watch","source","id","exprOrFn","cb","defaultRE","util","getValue","expr","split","reduce","memo","current","node","textContent","replace","Vue","options","_init","el","$mount","_update","firstChild","$el","document","createDocumentFragment","appendChild","compiler","childNodes","child","nodeType","compilerText","querySelector","query","msg","school","age","arr","a"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { observer } from \".\";\r\n\r\n// 原生方法劫持\r\n// 先获取老数组的方法，只改写7个方法\r\nlet oldArrayProtoMethods = Array.prototype\r\n\r\n// 拷贝一个新对象， 可以查找到老的方法\r\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\r\n\r\nlet methods = [\r\n    'push',\r\n    'shift',\r\n    'pop',\r\n    'unshift',\r\n    'reverse',\r\n    'sort',\r\n    'splice'\r\n]\r\n\r\nexport function observerArray(inserted) {\r\n    for(let i=0; i<inserted.length; i++) {\r\n        observer(inserted[i])\r\n    }\r\n}\r\n\r\nmethods.forEach(method => {\r\n    arrayMethods[method] = function(...args) {\r\n        console.log('>>调用劫持的原生方法：'+method)\r\n        let res = oldArrayProtoMethods[method].apply(this, args);\r\n\r\n        let inserted;\r\n        switch (method) {\r\n            case 'push':\r\n            case 'unshift':\r\n                inserted = args; break;\r\n            case 'splice':\r\n                inserted = args.slice(2); //获取新增的内容\r\n            default:\r\n                break;\r\n        }\r\n        // 若有数据添加就劫持\r\n        if (inserted) observerArray(inserted);\r\n\r\n        return res;\r\n    }\r\n\r\n})","import {observer} from './index'\r\nimport {arrayMethods, observerArray} from './array'\r\n\r\nexport function defineReactive(data, key, value) {\r\n    //如果value仍是一个object\r\n    observer(value);  //递归观察\r\n    // vue不支持ie8及以下浏览器\r\n    Object.defineProperty(data, key, {\r\n        get(){\r\n            console.log(\">>get...\")\r\n            return value;\r\n        },\r\n        set(newValue){\r\n            console.log(\">>set...\")\r\n            if (newValue === value) return;\r\n            // 如果新值是object则劫持\r\n            observer(newValue);\r\n            value = newValue;\r\n        }\r\n    })\r\n}\r\n\r\nclass Observer {\r\n    constructor(data) { //data === vm._data\r\n        // console.log('observer', data)\r\n        // 将用户的数据使用defineProperty重新定义\r\n        if (Array.isArray(data)) {\r\n            //在data上赋于新的原型方法\r\n            data.__proto__ = arrayMethods\r\n            //如果data里有object则劫持数组中的每一项\r\n            observerArray(data)\r\n        }else{\r\n            this.walk(data);\r\n        }\r\n    }\r\n    walk(data) {\r\n        let keys = Object.keys(data);\r\n        for (let i=0; i< keys.length; i++) {\r\n            let key = keys[i];\r\n            let value = data[keys[i]];\r\n            defineReactive(data, key, value);\r\n        }\r\n    }\r\n}\r\n\r\nexport default Observer","import Observer from \"./observer\";\r\n\r\n// 各种初始化工作\r\nexport function initState(vm) {\r\n    // console.log('initState')\r\n    let opts = vm.$options;\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    if (opts.computed) {\r\n        initComputed();\r\n    }\r\n    if (opts.watch) {\r\n        initWatch();\r\n    }\r\n}\r\n\r\n//此方法可能初外部使用则导出\r\nexport function observer(data) {\r\n    if (typeof data !== 'object' || data == null) {\r\n        return;\r\n    }\r\n    //若是object,则交给Observer对象处理，使用defineProperty\r\n    return new Observer(data);\r\n}\r\n\r\n// 代理数据访问 vm.msg == vm._data.msg\r\nfunction proxy(vm, source, key) {\r\n    Object.defineProperty(vm, key, {\r\n        get() {\r\n            return vm[source][key]\r\n        },\r\n        set(newValue) {\r\n            vm[source][key] = newValue\r\n        }\r\n    })\r\n}\r\n\r\nfunction initData(vm) {\r\n    let data = vm.$options.data;//用户数据\r\n    //若用户数据是fun则处理成数据\r\n    data = vm._data = typeof data === 'function'? data.call(vm): data || {}\r\n    \r\n    //将vm.msg代理到vm._data.msg上\r\n    for (let key in data) {\r\n        proxy(vm, '_data', key)\r\n    }\r\n\r\n    observer(vm._data) //观察数据\r\n}\r\n\r\nfunction initComputed() {\r\n\r\n}\r\n\r\nfunction initWatch() {\r\n\r\n}","let id = 0;\r\nclass Watcher{ // 每次产生一个watcher，都需要一个唯一标识\r\n    /**\r\n     * \r\n     * @param {*} vm 当前组件的实例\r\n     * @param {*} exprOrFn 表达式或函数\r\n     * @param {*} cb 传入的回调函数vm.$watch('msg', cb)\r\n     * @param {*} opts 其它参数\r\n     */\r\n    constructor(vm, exprOrFn, cb=()=>{}, opts={}) {\r\n        this.vm = vm;\r\n        this.exprOrFn = exprOrFn;\r\n        if (typeof exprOrFn === 'function') {\r\n            this.getter = exprOrFn; // getter就是new Watcher传入的第二个参数\r\n        }\r\n        this.cb = cb;\r\n        this.opts = opts;\r\n        this.id = id++;\r\n\r\n        this.get(); //默认创建一个watcher 会调用自身的get方法\r\n    }\r\n    get(){\r\n        this.getter(); //让当前传入的函数执行\r\n    }\r\n}\r\n// 渲染、计算属性及watch都要使用Watcher\r\nexport default Watcher","// ?: 匹配不捕获\r\n// + 至少一个\r\n// ? 尽可能少匹配\r\n// . 除换行符以外任意字符\r\n// win-\\r回车\\n换行 unix-只有\\n mac-只有\\r\r\n// /\\{\\{((?:.|\\r?\\n)+?)\\}}/.test(\"{{msg}}\")\r\n// \"{{msg}}\".match(/\\{\\{((?:.|\\r?\\n)+?)\\}}/)\r\nconst defaultRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\r\nexport const util = {\r\n    getValue(vm, expr){ // [school, name]\r\n        let keys = expr.split(\".\");\r\n        return keys.reduce((memo, current)=>{ //迭代依次取出school.name.xxx\r\n            memo = memo[current];\r\n            return memo;\r\n        },vm)\r\n        // [1,2,3].reduce((m,current)=>{\r\n        //     m+=current\r\n        //     return m\r\n        // },0)\r\n    },\r\n    compilerText(node,vm){//编译文本 替换{{xxx}}\r\n        node.textContent = node.textContent.replace(defaultRE, function(...args){\r\n            return util.getValue(vm, args[1]);\r\n        })\r\n    }\r\n}\r\n\r\nexport function compiler(node, vm){\r\n    let childNodes = node.childNodes;\r\n    [...childNodes].forEach(child=>{\r\n        //1-元素  3-文本\r\n        if (child.nodeType == 1) {\r\n            compiler(child, vm); //递归调用\r\n        } else if (child.nodeType == 3) {\r\n            util.compilerText(child,vm); //先写这个\r\n        }\r\n    })\r\n}","import { initState } from \"./observe\";\r\nimport Watcher from \"./observe/watcher\";\r\nimport {compiler, util} from './util'\r\n\r\n// console.log('vue')\r\nfunction Vue(options) {\r\n    // console.log(options)\r\n    this._init(options);\r\n}\r\n\r\nVue.prototype._init = function (options) {\r\n    //初始化，将options存在vm实例中\r\n    let vm = this;\r\n    vm.$options = options;\r\n\r\n    //MVVM 重新初始化options中的属性，如data,methods\r\n    initState(vm);\r\n\r\n    if (vm.$options.el) {\r\n        vm.$mount();\r\n    }\r\n}\r\n\r\nfunction query(el) {\r\n    if (typeof el === 'string') {\r\n        return document.querySelector(el);\r\n    }\r\n    return el;\r\n}\r\n\r\nVue.prototype._update = function() {\r\n    // 传入的数据，更新视图\r\n    let vm = this;\r\n    let el = vm.$el;\r\n\r\n    // 以下逻辑，会用虚拟dom重写的\r\n    // 要循环这个元素，将里面的内容换成我们的数据\r\n    let node = document.createDocumentFragment();\r\n    let firstChild;\r\n    //每次拿到第一个元素就将这个元素放入到文档碎片中\r\n    while(firstChild = el.firstChild){\r\n        node.appendChild(firstChild);\r\n    }\r\n    //此时打开页面会闪一下变成空白，因为appendChild把它移到文档碎片中了\r\n    console.log(node);//打印内存碎片\r\n\r\n    // todo 对文本进行替换 匹配{{}}来进行替换\r\n    compiler(node,vm);\r\n\r\n    //将内存碎片输出到dom\r\n    el.appendChild(node);\r\n\r\n    // 依赖收集，属性变化了，需要重新渲染watcher和dep\r\n}\r\n\r\nVue.prototype.$mount = function() {\r\n    let vm = this;\r\n    let el = vm.$options.el;\r\n    el = vm.$el = query(el); // 当前挂载dom\r\n\r\n    //渲染时通过watcher来渲染\r\n    let updateComponent = ()=>{ //可能是更新组件或渲染逻辑\r\n        console.log('watcher run')\r\n        vm._update(); // 更新组件\r\n    }\r\n    new Watcher(vm, updateComponent); //渲染watcher\r\n    \r\n}\r\n\r\nexport default Vue","import Vue from 'vue'\r\n\r\nlet vm = new Vue({\r\n    el: '#app',\r\n    data(){\r\n        return {\r\n            msg: 'hello',\r\n            school: {name: 'aaa', age: 10},\r\n            arr: [1,2,3,{a:1}]\r\n        }\r\n    },\r\n    computed: {\r\n\r\n    },\r\n    watch: {\r\n\r\n    }\r\n})\r\n// console.log(vm._data.msg)\r\n// vm.msg = 'test'\r\n//添加代理访问后可以这样使用\r\n// console.log(vm.msg)\r\n\r\n// vm.msg = {text:'hello'}\r\n// console.log(vm.msg.text)\r\n\r\n//不能劫持原生的push方法，vm.arr相当于读取，可以看到arr中新加的数据没有getset\r\n// console.log(vm.arr.push(4), vm.arr)\r\n//添加对象后，再访问属性没有劫持日志\r\n// console.log(vm.arr.push({a:1}), vm.arr[3].a)\r\n\r\n//这种情况只有get没有set\r\n// console.log(vm.arr[3].a=100)\r\n// console.log(vm.arr=[])\r\n\r\n// [1,2,3] 这样的数据不会被劫持 [{a:1}]会被劫持\r\n// console.log(vm.arr[0]=100)\r\n// [].push shift unshift 这些方法可以被监控， vm.$set内部调用就是数组的splice"],"sourceRoot":""}